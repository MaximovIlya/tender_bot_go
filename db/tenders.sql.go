// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tenders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const activatePendingTenders = `-- name: ActivatePendingTenders :exec
UPDATE tenders 
SET status = 'active' 
WHERE status = 'active_pending' 
AND start_at <= NOW()
`

func (q *Queries) ActivatePendingTenders(ctx context.Context) error {
	_, err := q.db.Exec(ctx, activatePendingTenders)
	return err
}

const approveTender = `-- name: ApproveTender :exec
UPDATE tenders 
SET status = 'active_pending'
WHERE id = $1
`

func (q *Queries) ApproveTender(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, approveTender, id)
	return err
}

const checkTenderParticipation = `-- name: CheckTenderParticipation :one
SELECT EXISTS(
    SELECT 1 FROM tender_participants 
    WHERE tender_id = $1 AND user_id = $2
) as is_participating
`

type CheckTenderParticipationParams struct {
	TenderID int32 `json:"tender_id"`
	UserID   int64 `json:"user_id"`
}

func (q *Queries) CheckTenderParticipation(ctx context.Context, arg CheckTenderParticipationParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkTenderParticipation, arg.TenderID, arg.UserID)
	var is_participating bool
	err := row.Scan(&is_participating)
	return is_participating, err
}

const checkUserHasAnyTenderParticipation = `-- name: CheckUserHasAnyTenderParticipation :one
SELECT EXISTS(
    SELECT 1 FROM tender_participants 
    WHERE user_id = $1 
    AND tender_id != $2  -- исключаем текущий тендер
) as has_participation
`

type CheckUserHasAnyTenderParticipationParams struct {
	UserID   int64 `json:"user_id"`
	TenderID int32 `json:"tender_id"`
}

func (q *Queries) CheckUserHasAnyTenderParticipation(ctx context.Context, arg CheckUserHasAnyTenderParticipationParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserHasAnyTenderParticipation, arg.UserID, arg.TenderID)
	var has_participation bool
	err := row.Scan(&has_participation)
	return has_participation, err
}

const createTender = `-- name: CreateTender :one
INSERT INTO tenders(title, description, start_price, start_at, conditions_path, current_price, classification)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, title, description, start_price, start_at, status, conditions_path, created_at, classification, participants_count, last_bid_at, current_price, min_bid_decrease
`

type CreateTenderParams struct {
	Title          string             `json:"title"`
	Description    pgtype.Text        `json:"description"`
	StartPrice     float64            `json:"start_price"`
	StartAt        pgtype.Timestamptz `json:"start_at"`
	ConditionsPath pgtype.Text        `json:"conditions_path"`
	CurrentPrice   float64            `json:"current_price"`
	Classification pgtype.Text        `json:"classification"`
}

func (q *Queries) CreateTender(ctx context.Context, arg CreateTenderParams) (Tender, error) {
	row := q.db.QueryRow(ctx, createTender,
		arg.Title,
		arg.Description,
		arg.StartPrice,
		arg.StartAt,
		arg.ConditionsPath,
		arg.CurrentPrice,
		arg.Classification,
	)
	var i Tender
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.StartPrice,
		&i.StartAt,
		&i.Status,
		&i.ConditionsPath,
		&i.CreatedAt,
		&i.Classification,
		&i.ParticipantsCount,
		&i.LastBidAt,
		&i.CurrentPrice,
		&i.MinBidDecrease,
	)
	return i, err
}

const deleteTender = `-- name: DeleteTender :exec
DELETE FROM tenders WHERE id = $1
`

func (q *Queries) DeleteTender(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteTender, id)
	return err
}

const getHistory = `-- name: GetHistory :many
SELECT id, title, description, start_price, start_at, status, conditions_path, created_at, classification, participants_count, last_bid_at, current_price, min_bid_decrease FROM tenders WHERE status = 'completed' ORDER BY created_at DESC
`

func (q *Queries) GetHistory(ctx context.Context) ([]Tender, error) {
	rows, err := q.db.Query(ctx, getHistory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tender{}
	for rows.Next() {
		var i Tender
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.StartPrice,
			&i.StartAt,
			&i.Status,
			&i.ConditionsPath,
			&i.CreatedAt,
			&i.Classification,
			&i.ParticipantsCount,
			&i.LastBidAt,
			&i.CurrentPrice,
			&i.MinBidDecrease,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStartingTenders = `-- name: GetStartingTenders :many
SELECT title, id, current_price, start_price 
FROM tenders WHERE start_at <= NOW()
AND status = 'active'
`

type GetStartingTendersRow struct {
	Title        string  `json:"title"`
	ID           int32   `json:"id"`
	CurrentPrice float64 `json:"current_price"`
	StartPrice   float64 `json:"start_price"`
}

func (q *Queries) GetStartingTenders(ctx context.Context) ([]GetStartingTendersRow, error) {
	rows, err := q.db.Query(ctx, getStartingTenders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStartingTendersRow{}
	for rows.Next() {
		var i GetStartingTendersRow
		if err := rows.Scan(
			&i.Title,
			&i.ID,
			&i.CurrentPrice,
			&i.StartPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTender = `-- name: GetTender :one
SELECT id, title, description, start_price, start_at, status, conditions_path, created_at, classification, participants_count, last_bid_at, current_price, min_bid_decrease FROM tenders WHERE id = $1
`

func (q *Queries) GetTender(ctx context.Context, id int32) (Tender, error) {
	row := q.db.QueryRow(ctx, getTender, id)
	var i Tender
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.StartPrice,
		&i.StartAt,
		&i.Status,
		&i.ConditionsPath,
		&i.CreatedAt,
		&i.Classification,
		&i.ParticipantsCount,
		&i.LastBidAt,
		&i.CurrentPrice,
		&i.MinBidDecrease,
	)
	return i, err
}

const getTenderById = `-- name: GetTenderById :one
SELECT id, title, description, start_price, start_at, status, conditions_path, created_at, classification, participants_count, last_bid_at, current_price, min_bid_decrease FROM tenders WHERE id = $1
`

func (q *Queries) GetTenderById(ctx context.Context, id int32) (Tender, error) {
	row := q.db.QueryRow(ctx, getTenderById, id)
	var i Tender
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.StartPrice,
		&i.StartAt,
		&i.Status,
		&i.ConditionsPath,
		&i.CreatedAt,
		&i.Classification,
		&i.ParticipantsCount,
		&i.LastBidAt,
		&i.CurrentPrice,
		&i.MinBidDecrease,
	)
	return i, err
}

const getTenders = `-- name: GetTenders :many
SELECT id, title, description, start_price, start_at, status, conditions_path, created_at, classification, participants_count, last_bid_at, current_price, min_bid_decrease FROM tenders ORDER BY created_at DESC
`

func (q *Queries) GetTenders(ctx context.Context) ([]Tender, error) {
	rows, err := q.db.Query(ctx, getTenders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tender{}
	for rows.Next() {
		var i Tender
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.StartPrice,
			&i.StartAt,
			&i.Status,
			&i.ConditionsPath,
			&i.CreatedAt,
			&i.Classification,
			&i.ParticipantsCount,
			&i.LastBidAt,
			&i.CurrentPrice,
			&i.MinBidDecrease,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTendersForDeletion = `-- name: GetTendersForDeletion :many
SELECT id, title, description, start_price, start_at, status, conditions_path, created_at, classification, participants_count, last_bid_at, current_price, min_bid_decrease FROM tenders 
WHERE status != 'completed' 
ORDER BY created_at DESC
`

func (q *Queries) GetTendersForDeletion(ctx context.Context) ([]Tender, error) {
	rows, err := q.db.Query(ctx, getTendersForDeletion)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tender{}
	for rows.Next() {
		var i Tender
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.StartPrice,
			&i.StartAt,
			&i.Status,
			&i.ConditionsPath,
			&i.CreatedAt,
			&i.Classification,
			&i.ParticipantsCount,
			&i.LastBidAt,
			&i.CurrentPrice,
			&i.MinBidDecrease,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTendersForSuppliers = `-- name: GetTendersForSuppliers :many
SELECT id, title, description, start_price, start_at, status, conditions_path, created_at, classification, participants_count, last_bid_at, current_price, min_bid_decrease FROM tenders 
WHERE (status = 'active' OR status = 'active_pending')
AND (classification = $1 OR classification = $2)
`

type GetTendersForSuppliersParams struct {
	Classification   pgtype.Text `json:"classification"`
	Classification_2 pgtype.Text `json:"classification_2"`
}

func (q *Queries) GetTendersForSuppliers(ctx context.Context, arg GetTendersForSuppliersParams) ([]Tender, error) {
	rows, err := q.db.Query(ctx, getTendersForSuppliers, arg.Classification, arg.Classification_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tender{}
	for rows.Next() {
		var i Tender
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.StartPrice,
			&i.StartAt,
			&i.Status,
			&i.ConditionsPath,
			&i.CreatedAt,
			&i.Classification,
			&i.ParticipantsCount,
			&i.LastBidAt,
			&i.CurrentPrice,
			&i.MinBidDecrease,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTendersStartingIn5Minutes = `-- name: GetTendersStartingIn5Minutes :many
SELECT title, start_at, id
FROM tenders 
WHERE start_at IS NOT NULL 
  AND start_at <= NOW() + INTERVAL '5 minutes'
  AND start_at > NOW()
ORDER BY start_at ASC
`

type GetTendersStartingIn5MinutesRow struct {
	Title   string             `json:"title"`
	StartAt pgtype.Timestamptz `json:"start_at"`
	ID      int32              `json:"id"`
}

func (q *Queries) GetTendersStartingIn5Minutes(ctx context.Context) ([]GetTendersStartingIn5MinutesRow, error) {
	rows, err := q.db.Query(ctx, getTendersStartingIn5Minutes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTendersStartingIn5MinutesRow{}
	for rows.Next() {
		var i GetTendersStartingIn5MinutesRow
		if err := rows.Scan(&i.Title, &i.StartAt, &i.ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const joinTender = `-- name: JoinTender :exec
WITH inserted AS (
    INSERT INTO tender_participants (tender_id, user_id)
    VALUES ($1, $2)
    ON CONFLICT (tender_id, user_id) DO NOTHING
    RETURNING 1
)
UPDATE tenders
SET participants_count = participants_count + 1
WHERE tenders.id = $1 AND EXISTS (SELECT 1 FROM inserted)
`

type JoinTenderParams struct {
	ID     int32 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) JoinTender(ctx context.Context, arg JoinTenderParams) error {
	_, err := q.db.Exec(ctx, joinTender, arg.ID, arg.UserID)
	return err
}

const leaveTender = `-- name: LeaveTender :exec
WITH deleted AS (
    DELETE FROM tender_participants 
    WHERE tender_id = $1 AND user_id = $2
    RETURNING 1
)
UPDATE tenders
SET participants_count = participants_count - 1
WHERE tenders.id = $1 AND EXISTS (SELECT 1 FROM deleted)
`

type LeaveTenderParams struct {
	ID     int32 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) LeaveTender(ctx context.Context, arg LeaveTenderParams) error {
	_, err := q.db.Exec(ctx, leaveTender, arg.ID, arg.UserID)
	return err
}

const updateTenderStatus = `-- name: UpdateTenderStatus :exec
UPDATE tenders SET status = $2 WHERE id = $1
`

type UpdateTenderStatusParams struct {
	ID     int32  `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateTenderStatus(ctx context.Context, arg UpdateTenderStatusParams) error {
	_, err := q.db.Exec(ctx, updateTenderStatus, arg.ID, arg.Status)
	return err
}
